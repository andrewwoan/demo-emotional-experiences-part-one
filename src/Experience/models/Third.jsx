/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 Third_New-v3.glb 
*/

import React, { useMemo } from "react";
import { useGLTF, Float } from "@react-three/drei";
import { useThree } from "@react-three/fiber";
import * as THREE from "three";
import { KTX2Loader } from "three-stdlib";

import { convertMaterialsToBasic } from "../utils/convertToBasic";
import { useGLTFWithKTX2, useKTX2Loader } from "../utils/useGLTFWithKTX2";
import { ConditionalMesh } from "../utils/conditionalMesh";

export default function Model({
  progress,
  loopCounter,
  animationTime,
  ...props
}) {
  const { gl } = useThree();
  const { nodes, materials } = useGLTFWithKTX2("/models/Third_New-v3.glb");
  const newmaterials = convertMaterialsToBasic(materials);

  const ktx2Loader = useKTX2Loader();
  // Cache KTX2 textures (loaded only once)
  const ktx2Textures = useMemo(() => {
    const textures = {};

    // Load KTX2 textures
    ktx2Loader.load("/textures/third/third_night.ktx2", (texture) => {
      texture.flipY = false;
      textures.third_Baked = texture;
    });

    ktx2Loader.load("/textures/third/second_night.ktx2", (texture) => {
      texture.flipY = false;
      textures.second_Baked = texture;
    });

    ktx2Loader.load("/textures/third/first_night.ktx2", (texture) => {
      texture.flipY = false;
      textures.first_Baked = texture;
    });

    return textures;
  }, [gl]);

  // Create materials based on loopCounter
  const ktx2Materials = useMemo(() => {
    if (loopCounter % 2 === 0) {
      // Use KTX2 textures for even loops
      return {
        third_Baked: new THREE.MeshBasicMaterial({
          map: ktx2Textures.third_Baked,
          transparent: true,
          alphaTest: 0.5,
        }),
        second_Baked: new THREE.MeshBasicMaterial({
          map: ktx2Textures.second_Baked,
          transparent: true,
          alphaTest: 0.5,
        }),
        first_Baked: new THREE.MeshBasicMaterial({
          map: ktx2Textures.first_Baked,
          transparent: true,
          alphaTest: 0.5,
        }),
      };
    }
    // Clone newmaterials and set flipY = false for their textures
    const clonedMaterials = {};
    Object.keys(newmaterials).forEach((key) => {
      clonedMaterials[key] = newmaterials[key].clone();
      if (clonedMaterials[key].map) {
        clonedMaterials[key].map.flipY = false;
      }
    });
    return clonedMaterials;
  }, [loopCounter, newmaterials, ktx2Textures]);

  // Dispose of textures when component unmounts
  useMemo(() => {
    return () => {
      Object.values(ktx2Textures).forEach((texture) => {
        if (texture) texture.dispose();
      });
    };
  }, [ktx2Textures]);

  // Animation configuration
  const animationConfig = {
    hiddenDoor: {
      start: 0.9335,
      end: 0.95,
      maxRotation: Math.PI / 2, // 90 degrees on Z-axis
    },
    ship: {
      start: 0.9,
      end: 0.935,
      maxPositionY: -2.5, // Move down slightly
    },
    leftArm: {
      start: 0.9,
      end: 0.935,
      maxPositionY: -3.5, // Move down slightly
      maxRotationZ: Math.PI / 8, // Maximum rotation angle for oscillation (30 degrees)
      rotationSpeed: 2, // Speed of oscillation
    },
    rightArm: {
      start: 0.9,
      end: 0.935,
      maxPositionY: -3.5, // Move down slightly
      maxRotationZ: Math.PI / 8, // Maximum rotation angle for oscillation (30 degrees)
      rotationSpeed: 2, // Speed of oscillation
    },
    plane017: {
      start: 0.9,
      end: 0.935,
      maxPositionY: -3.5, // Move down slightly
    },
    miffy: {
      start: 0.9,
      end: 0.935,
      maxPositionY: -2.5, // Move down slightly (same as ship)
    },
    boris: {
      start: 0.9,
      end: 0.935,
      maxPositionY: -2.5, // Move down slightly (same as ship)
    },
  };

  // Helper function to calculate animation progress
  const calculateAnimationAmount = (config) => {
    if (progress < config.start) return 0;
    if (progress > config.end) return 1;

    return (progress - config.start) / (config.end - config.start);
  };

  // Calculate animations
  const hiddenDoorProgress = useMemo(
    () => calculateAnimationAmount(animationConfig.hiddenDoor),
    [progress]
  );
  const shipProgress = useMemo(
    () => calculateAnimationAmount(animationConfig.ship),
    [progress]
  );
  const leftArmProgress = useMemo(
    () => calculateAnimationAmount(animationConfig.leftArm),
    [progress]
  );
  const rightArmProgress = useMemo(
    () => calculateAnimationAmount(animationConfig.rightArm),
    [progress]
  );
  const plane017Progress = useMemo(
    () => calculateAnimationAmount(animationConfig.plane017),
    [progress]
  );
  const miffyProgress = useMemo(
    () => calculateAnimationAmount(animationConfig.miffy),
    [progress]
  );
  const borisProgress = useMemo(
    () => calculateAnimationAmount(animationConfig.boris),
    [progress]
  );

  const leftArmRotation = useMemo(() => {
    const baseRotation = [-1.566, -0.042, -3.004];
    const oscillation =
      Math.sin(animationTime * animationConfig.leftArm.rotationSpeed) *
      animationConfig.leftArm.maxRotationZ;
    return [baseRotation[0], baseRotation[1] + oscillation, baseRotation[2]];
  }, [animationTime]);

  const rightArmRotation = useMemo(() => {
    const baseRotation = [-1.566, -0.042, -3.004];
    const oscillation =
      Math.sin(animationTime * animationConfig.rightArm.rotationSpeed) *
      animationConfig.rightArm.maxRotationZ;
    return [baseRotation[0], baseRotation[1] - oscillation, baseRotation[2]];
  }, [animationTime]);

  // Calculate final transformations
  const hiddenDoorRotation = useMemo(() => {
    const baseRotation = [-Math.PI / 2, 0, -3.003];
    return [
      baseRotation[0],
      baseRotation[1],
      baseRotation[2] -
        animationConfig.hiddenDoor.maxRotation * hiddenDoorProgress,
    ];
  }, [hiddenDoorProgress]);

  const shipPosition = useMemo(() => {
    const basePosition = [-1.144, -2.096, -42.695];
    return [
      basePosition[0] + animationConfig.ship.maxPositionY * shipProgress,
      basePosition[1],
      basePosition[2],
    ];
  }, [shipProgress]);

  const leftArmPosition = useMemo(() => {
    const basePosition = [4.968, 1.501, -43.489];
    return [
      basePosition[0] + animationConfig.leftArm.maxPositionY * leftArmProgress,
      basePosition[1],
      basePosition[2],
    ];
  }, [leftArmProgress]);

  const rightArmPosition = useMemo(() => {
    const basePosition = [6.6, 1.406, -43.773];
    return [
      basePosition[0] +
        animationConfig.rightArm.maxPositionY * rightArmProgress,
      basePosition[1],
      basePosition[2],
    ];
  }, [rightArmProgress]);

  const plane017Position = useMemo(() => {
    const basePosition = [5.891, -2.478, -43.788];
    return [
      basePosition[0] +
        animationConfig.plane017.maxPositionY * plane017Progress,
      basePosition[1],
      basePosition[2],
    ];
  }, [plane017Progress]);

  const miffyPosition = useMemo(() => {
    const basePosition =
      loopCounter % 2 === 0
        ? [0.3, 0.5, -43.0] // Custom position for even loops
        : [0.575, 1.074, -42.836]; // Original position for odd loops

    return [
      basePosition[0] + animationConfig.miffy.maxPositionY * miffyProgress,
      basePosition[1],
      basePosition[2],
    ];
  }, [miffyProgress, loopCounter]);

  const borisPosition = useMemo(() => {
    const basePosition =
      loopCounter % 2 === 0
        ? [-2.9, 0.5, -42.5] // Custom position for even loops
        : [-3.321, 0.872, -42.277]; // Original position for odd loops

    return [
      basePosition[0] + animationConfig.boris.maxPositionY * borisProgress,
      basePosition[1],
      basePosition[2],
    ];
  }, [borisProgress, loopCounter]);

  // Custom rotations for even loop counters
  const miffyRotation = useMemo(() => {
    return loopCounter % 2 === 0
      ? [-1.566, 1.542, -3.004] // Custom rotation for even loops
      : [-1.566, -0.042, -3.004]; // Original rotation for odd loops
  }, [loopCounter]);

  const borisRotation = useMemo(() => {
    return loopCounter % 2 === 0
      ? [-1.566, -1.3, -3.004] // Custom rotation for even loops
      : [-1.566, -0.042, -3.004]; // Original rotation for odd loops
  }, [loopCounter]);

  // Third_Baked position based on loopCounter
  const thirdBakedPosition = useMemo(() => {
    return [6.585, loopCounter % 2 === 0 ? -5.3 : -4.978, -41.493];
  }, [loopCounter]);

  return (
    <group {...props} dispose={null}>
      <ConditionalMesh progress={progress} showRange={[0.755, 0.99]}>
        <mesh
          geometry={nodes.First_Paper_Baked.geometry}
          material={ktx2Materials.first_Baked}
          position={[0.168, -0.712, -44.536]}
          rotation={[-Math.PI / 2, 0, -3.003]}
          scale={[-20.58, -2.026, -24.108]}
        />

        <mesh
          geometry={nodes.Third_Baked.geometry}
          material={ktx2Materials.third_Baked}
          position={thirdBakedPosition}
          rotation={[Math.PI, -0.138, Math.PI]}
          scale={0.19}
        />
        <mesh
          geometry={nodes.Hidden_Door.geometry}
          material={ktx2Materials.first_Baked}
          position={[0.911, 1.124, -44.639]}
          rotation={hiddenDoorRotation}
          scale={[-20.58, -2.026, -24.108]}
        />
        <Float
          speed={1.5}
          rotationIntensity={0.1}
          floatIntensity={1}
          floatingRange={[-0.05, 0.05]}
        >
          <mesh
            geometry={nodes.Ocean002.geometry}
            material={ktx2Materials.third_Baked}
            position={[3.697, -5.756, -41.602]}
            rotation={[Math.PI, -0.138, Math.PI]}
            scale={0.19}
          />

          <mesh
            geometry={nodes.Ocean003.geometry}
            material={ktx2Materials.third_Baked}
            position={[6.585, -4.978, -41.493]}
            rotation={[Math.PI, -0.138, Math.PI]}
            scale={0.19}
          />
        </Float>

        <Float
          speed={1.5}
          rotationIntensity={0.1}
          floatIntensity={1}
          floatingRange={[-0.05, 0.05]}
        >
          <mesh
            geometry={nodes.Ocean.geometry}
            material={ktx2Materials.third_Baked}
            position={[-3.971, -6.047, -40.799]}
            rotation={[Math.PI, -0.138, Math.PI]}
            scale={0.19}
          />
          <mesh
            geometry={nodes.Ocean001.geometry}
            material={ktx2Materials.third_Baked}
            position={[-1.568, -6.83, -40.595]}
            rotation={[Math.PI, -0.138, Math.PI]}
            scale={0.19}
          />
        </Float>

        <Float
          speed={1.2}
          rotationIntensity={0.1}
          floatIntensity={1}
          floatingRange={[-0.01, 0.01]}
        >
          <group
            position={plane017Position}
            rotation={[-1.566, -0.042, -3.004]}
            scale={0.19}
          >
            <mesh
              geometry={nodes.Plane017.geometry}
              material={ktx2Materials.second_Baked}
            />
            <mesh
              geometry={nodes.Plane017_1.geometry}
              material={ktx2Materials.third_Baked}
            />
          </group>
          <mesh
            geometry={nodes.Right_Arm.geometry}
            material={ktx2Materials.second_Baked}
            position={rightArmPosition}
            rotation={rightArmRotation}
            scale={0.19}
          />
          <mesh
            geometry={nodes.Left_Arm.geometry}
            material={ktx2Materials.second_Baked}
            position={leftArmPosition}
            rotation={leftArmRotation}
            scale={0.19}
          />
        </Float>

        <Float
          speed={1.2}
          rotationIntensity={0.07}
          floatIntensity={0.7}
          floatingRange={[-0.05, 0.01]}
        >
          <group
            position={shipPosition}
            rotation={[-1.566, -0.042, -3.004]}
            scale={0.19}
          >
            <mesh
              geometry={nodes.Plane020.geometry}
              material={ktx2Materials.second_Baked}
            />
            <mesh
              geometry={nodes.Plane020_1.geometry}
              material={ktx2Materials.third_Baked}
            />
          </group>

          <mesh
            geometry={nodes.Miffy.geometry}
            material={ktx2Materials.second_Baked}
            position={miffyPosition}
            rotation={miffyRotation}
            scale={0.19}
          />
          <mesh
            geometry={nodes.Boris.geometry}
            material={ktx2Materials.second_Baked}
            position={borisPosition}
            rotation={borisRotation}
            scale={0.19}
          />
        </Float>
        <mesh
          geometry={nodes.Sun.geometry}
          material={ktx2Materials.second_Baked}
          position={[-4.926, 5.116, -42.575]}
          rotation={[-1.566, -0.042, -3.004]}
          scale={0.19}
        />
        <mesh
          geometry={nodes.Seagull.geometry}
          material={ktx2Materials.second_Baked}
          position={[0.575, 1.074, -42.836]}
          rotation={[-1.566, -0.042, -3.004]}
          scale={0.19}
        />
        <mesh
          geometry={nodes.Seagull001.geometry}
          material={ktx2Materials.second_Baked}
          position={[0.575, 1.074, -42.836]}
          rotation={[-1.566, -0.042, -3.004]}
          scale={0.19}
        />
        <mesh
          geometry={nodes.Seagull002.geometry}
          material={ktx2Materials.second_Baked}
          position={[0.575, 1.074, -42.836]}
          rotation={[-1.566, -0.042, -3.004]}
          scale={0.19}
        />
      </ConditionalMesh>
    </group>
  );
}
